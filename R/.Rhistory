install.packages("devtools")
devtools::install_github("jendelman/GWASpoly", build_vignettes=FALSE)
devtools::install_github("mmollina/mappoly", dependencies=TRUE)
install.packages("qtlpoly")
install.packages("words")
words::words
dictionary<-words::words
five = dictionary[which(dictionary$word_length==5),]
View(five)
dictionary=words
five = dictionary[which(dictionary$word_length==5),]
dictionary=words()
library(words)
dictionary=words()
dictionary=words
five = dictionary[which(dictionary$word_length==5),]
a:z
letters
letter_counts = matrix(NA, 26,2)
letter_counts = colnames("letter","count")
letter_counts[,1] = letters
View(letter_counts)
str_count(five[,1],"a")
install.packages("stringr")
stringr::str_count(five[,1],"a")
sum(stringr::str_count(five[,1],"a"))
for ( i in 1:length(letters)){
letter_counts[i,2] = sum(stringr::str_count(five[,1],letters[i]))
}
View(letter_counts)
View(letter_counts)
letter_counts = as.data.frame(letter_counts)
library(words)
dictionary=words
five = dictionary[which(dictionary$word_length==5),]
letter_counts = matrix(NA, 26,2)
letter_counts = colnames("letter","count")
letter_counts[,1] = letters
for ( i in 1:length(letters)){
letter_counts[i,2] = sum(stringr::str_count(five[,1],letters[i]))
}
View(letter_counts)
letter_counts = colnames("letter","count")
colnames(letter_counts) = c("letter","count")
View(letter_counts)
#new script to see try to find the best word to start wordle with
library(words)
dictionary=words
five = dictionary[which(dictionary$word_length==5),]
# letter counts of the whole word
letter_counts = matrix(NA, 26,2)
colnames(letter_counts) = c("letter","count")
letter_counts[,1] = letters
for ( i in 1:length(letters)){
letter_counts[i,2] = sum(stringr::str_count(five[,1],letters[i]))
}
letter_counts = as.data.frame(letter_counts)
letter_counts$count = as.numeric(letter_counts$count)
barplot(letter_counts$count, names.arg = letter_counts$letter)
####### now make a matrix where 5 possible positions and 9330 rows for all the 5 letter words
sep_matrix = matrix(NA,nrow(five),5)
for (i in 1:nrow(five)){
sep_matrix[i,1:5] = unlist(strsplit(five[i,1],""))
}
#### new matrix that is the count of all the letters
letter_count_matrix = matrix(NA, length(letters), 5)
rownames(letter_count_matrix)=letters
for (i in 1:5){
for (j in 1:26){
letter_count_matrix[j,i] = sum(stringr::str_count(sep_matrix[,i],letters[j]))
}
print(i)
}
sum(stringr::str_count(sep_matrix[,1],letters[1]))
View(sep_matrix)
View(letter_count_matrix)
View(letter_count_matrix)
five_points = five
sep_matrix[1,1]
which[row.names(letter_count_matrix)==sep_matrix[1,1])]
rownames(letter_count_matrix)
rownames(letter_count_matrix)=="a"
which(row.names(letter_count_matrix)==sep_matrix[1,1]))
which(row.names(letter_count_matrix)==sep_matrix[1,1]))
which(rownames(letter_count_matrix)=="a")
which(rownames(letter_count_matrix)=="b")
which(rownames(letter_count_matrix)==sep_matrix[1,1])
View(sep_matrix)
sep_matrix_points = sep_matrix
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[1,1]),1]
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[1,1]),1]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[1,2]),2]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[1,3]),3]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[1,4]),4]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[1,5]),5]
View(letter_count_matrix)
View(sep_matrix_points)
View(letter_count_matrix)
for (i in 1:nrow(sep_matrix)){
five_points[i,2]=
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,1]),1]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,2]),2]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,3]),3]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,4]),4]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,5]),5]
print(i)
}
View(five_points)
View(five_points)
View(five_points)
View(sep_matrix_points)
####### now make a matrix where 5 possible positions and 9330 rows for all the 5 letter words
ptm <- proc.time()
sep_matrix = matrix(NA,nrow(five),5)
for (i in 1:nrow(five)){
sep_matrix[i,1:5] = unlist(strsplit(five[i,1],""))
}
#### new matrix that is the count of all the letters
letter_count_matrix = matrix(NA, length(letters), 5)
rownames(letter_count_matrix)=letters
for (i in 1:5){
for (j in 1:26){
letter_count_matrix[j,i] = sum(stringr::str_count(sep_matrix[,i],letters[j]))
}
print(i)
}
sum(stringr::str_count(sep_matrix[,1],letters[1]))
five_points = five
for (i in 1:nrow(sep_matrix)){
five_points[i,2]=
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,1]),1]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,2]),2]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,3]),3]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,4]),4]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,5]),5]
print(i)
}
proc.time() - ptm
View(dictionary)
View(five)
View(sep_matrix_points)
View(letter_counts)
View(letter_counts)
View(letter_counts)
View(five)
View(letter_count_matrix)
View(letter_counts)
View(letter_count_matrix)
View(five_points)
devtools::install_github("jendelman/diaQTL", build_vignettes=FALSE)
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
install.packages(c("brew", "broom", "doParallel", "dplyr", "foreach", "iterators", "lme4", "quantreg", "rlang", "tidyr"))
devtools::install_github("jendelman/diaQTL", build_vignettes=FALSE)
devtools::install_github("jendleman/diaQTL",ref="a78cbd7436de907a4a62c3710ecb3051a71d6a3a")
devtools::install_github("jendelman/diaQTL",ref="a78cbd7436de907a4a62c3710ecb3051a71d6a3a")
reticulate::repl_python()
print ("hellow")
n
print ("hellow")
for i in length(5):
print("hi")
for i in range(5):
print("hi")
for i in range(5):
print("hi")
for i in range(5):
print("hi")
#new script to see try to find the best word to start wordle with
library(words)
dictionary=words
five = dictionary[which(dictionary$word_length==5),]
# letter counts of the whole word
letter_counts = matrix(NA, 26,2)
colnames(letter_counts) = c("letter","count")
letter_counts[,1] = letters
for ( i in 1:length(letters)){
letter_counts[i,2] = sum(stringr::str_count(five[,1],letters[i]))
}
letter_counts = as.data.frame(letter_counts)
letter_counts$count = as.numeric(letter_counts$count)
barplot(letter_counts$count, names.arg = letter_counts$letter)
####### now make a matrix where 5 possible positions and 9330 rows for all the 5 letter words
ptm <- proc.time()
sep_matrix = matrix(NA,nrow(five),5)
for (i in 1:nrow(five)){
sep_matrix[i,1:5] = unlist(strsplit(five[i,1],""))
}
#### new matrix that is the count of all the letters
letter_count_matrix = matrix(NA, length(letters), 5)
rownames(letter_count_matrix)=letters
for (i in 1:5){
for (j in 1:26){
letter_count_matrix[j,i] = sum(stringr::str_count(sep_matrix[,i],letters[j]))
}
print(i)
}
sum(stringr::str_count(sep_matrix[,1],letters[1]))
five_points = five
for (i in 1:nrow(sep_matrix)){
five_points[i,2]=
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,1]),1]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,2]),2]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,3]),3]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,4]),4]+
letter_count_matrix[which(rownames(letter_count_matrix)==sep_matrix[i,5]),5]
print(i)
}
proc.time() - ptm
letters_green = readline('Input 5 characters ("?" for unknown and "x" for right letter')
View(sep_matrix)
sep_matrix[which(sep_matrix[,4]=="e"),]
new_matrix=sep_matrix[which(sep_matrix[,4]=="e"),]
View(new_matrix)
# Create data
set.seed(1)
treatment <- rep(c("A", "B", "C", "D", "E"), each=20)
value=c( sample(2:5, 20 , replace=T) , sample(6:10, 20 , replace=T), sample(1:7, 20 , replace=T), sample(3:10, 20 , replace=T) , sample(10:20, 20 , replace=T) )
data=data.frame(treatment,value)
# What is the effect of the treatment on the value ?
model=lm( data$value ~ data$treatment )
ANOVA=aov(model)
# Tukey test to study each pair of treatment :
TUKEY <- TukeyHSD(x=ANOVA, 'data$treatment', conf.level=0.95)
# Tuckey test representation :
plot(TUKEY , las=1 , col="brown")
# I need to group the treatments that are not different each other together.
generate_label_df <- function(TUKEY, variable){
# Extract labels and factor levels from Tukey post-hoc
Tukey.levels <- TUKEY[[variable]][,4]
Tukey.labels <- data.frame(multcompLetters(Tukey.levels)['Letters'])
#I need to put the labels in the same order as in the boxplot :
Tukey.labels$treatment=rownames(Tukey.labels)
Tukey.labels=Tukey.labels[order(Tukey.labels$treatment) , ]
return(Tukey.labels)
}
# Apply the function on my dataset
LABELS <- generate_label_df(TUKEY , "data$treatment")
# A panel of colors to draw each group with the same color :
my_colors <- c(
rgb(143,199,74,maxColorValue = 255),
rgb(242,104,34,maxColorValue = 255),
rgb(111,145,202,maxColorValue = 255)
)
# Draw the basic boxplot
a <- boxplot(data$value ~ data$treatment , ylim=c(min(data$value) , 1.1*max(data$value)) , col=my_colors[as.numeric(LABELS[,1])] , ylab="value" , main="")
# I want to write the letter over each box. Over is how high I want to write it.
over <- 0.1*max( a$stats[nrow(a$stats),] )
#Add the labels
text( c(1:nlevels(data$treatment)) , a$stats[nrow(a$stats),]+over , LABELS[,1]  , col=my_colors[as.numeric(LABELS[,1])] )
# Create data
set.seed(1)
treatment <- rep(c("A", "B", "C", "D", "E"), each=20)
value=c( sample(2:5, 20 , replace=T) , sample(6:10, 20 , replace=T), sample(1:7, 20 , replace=T), sample(3:10, 20 , replace=T) , sample(10:20, 20 , replace=T) )
data=data.frame(treatment,value)
# What is the effect of the treatment on the value ?
model=lm( data$value ~ data$treatment )
ANOVA=aov(model)
# Tukey test to study each pair of treatment :
TUKEY <- TukeyHSD(x=ANOVA, 'data$treatment', conf.level=0.95)
# Tuckey test representation :
plot(TUKEY , las=1 , col="brown")
# I need to group the treatments that are not different each other together.
generate_label_df <- function(TUKEY, variable){
# Extract labels and factor levels from Tukey post-hoc
Tukey.levels <- TUKEY[[variable]][,4]
Tukey.labels <- data.frame(multcompView::multcompLetters(Tukey.levels)['Letters'])
#I need to put the labels in the same order as in the boxplot :
Tukey.labels$treatment=rownames(Tukey.labels)
Tukey.labels=Tukey.labels[order(Tukey.labels$treatment) , ]
return(Tukey.labels)
}
# Apply the function on my dataset
LABELS <- generate_label_df(TUKEY , "data$treatment")
# A panel of colors to draw each group with the same color :
my_colors <- c(
rgb(143,199,74,maxColorValue = 255),
rgb(242,104,34,maxColorValue = 255),
rgb(111,145,202,maxColorValue = 255)
)
# Draw the basic boxplot
a <- boxplot(data$value ~ data$treatment , ylim=c(min(data$value) , 1.1*max(data$value)) , col=my_colors[as.numeric(LABELS[,1])] , ylab="value" , main="")
# I want to write the letter over each box. Over is how high I want to write it.
over <- 0.1*max( a$stats[nrow(a$stats),] )
#Add the labels
text( c(1:nlevels(data$treatment)) , a$stats[nrow(a$stats),]+over , LABELS[,1]  , col=my_colors[as.numeric(LABELS[,1])] )
# Create data
set.seed(1)
treatment <- rep(c("A", "B", "C", "D", "E"), each=20)
value=c( sample(2:5, 20 , replace=T) , sample(6:10, 20 , replace=T), sample(1:7, 20 , replace=T), sample(3:10, 20 , replace=T) , sample(10:20, 20 , replace=T) )
data=data.frame(treatment,value)
# What is the effect of the treatment on the value ?
model=lm( data$value ~ data$treatment )
ANOVA=aov(model)
# Tukey test to study each pair of treatment :
TUKEY <- TukeyHSD(x=ANOVA, 'data$treatment', conf.level=0.95)
# Tuckey test representation :
plot(TUKEY , las=1 , col="brown")
# I need to group the treatments that are not different each other together.
generate_label_df <- function(TUKEY, variable){
# Extract labels and factor levels from Tukey post-hoc
Tukey.levels <- TUKEY[[variable]][,4]
Tukey.labels <- data.frame(multcompView::multcompLetters(Tukey.levels)['Letters'])
#I need to put the labels in the same order as in the boxplot :
Tukey.labels$treatment=rownames(Tukey.labels)
Tukey.labels=Tukey.labels[order(Tukey.labels$treatment) , ]
return(Tukey.labels)
}
# Apply the function on my dataset
LABELS <- generate_label_df(TUKEY , "data$treatment")
# A panel of colors to draw each group with the same color :
my_colors <- c(
rgb(143,199,74,maxColorValue = 255),
rgb(242,104,34,maxColorValue = 255),
rgb(111,145,202,maxColorValue = 255)
)
# Draw the basic boxplot
a <- boxplot(data$value ~ data$treatment , ylim=c(min(data$value) , 1.1*max(data$value)) , col=my_colors[as.numeric(LABELS[,1])] , ylab="value" , main="")
# I want to write the letter over each box. Over is how high I want to write it.
over <- 0.1*max( a$stats[nrow(a$stats),] )
#Add the labels
text( c(1:nlevels(data$treatment)) , a$stats[nrow(a$stats),]+over , LABELS[,1]  , col=my_colors[as.numeric(LABELS[,1])] )
setwd("~/GitHub/RoseArrayTools/R")
